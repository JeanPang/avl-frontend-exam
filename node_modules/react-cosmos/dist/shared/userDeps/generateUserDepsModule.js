"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.generateUserDepsModule = generateUserDepsModule;

var _path = _interopRequireDefault(require("path"));

var _slash = _interopRequireDefault(require("slash"));

var _findUserModulePaths2 = require("./findUserModulePaths");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

// Warning: Renderer config must be serializable!
function generateUserDepsModule(cosmosConfig, rendererConfig) {
  var rootDir = cosmosConfig.rootDir,
      fixturesDir = cosmosConfig.fixturesDir,
      fixtureFileSuffix = cosmosConfig.fixtureFileSuffix,
      globalImports = cosmosConfig.globalImports;

  var _findUserModulePaths = (0, _findUserModulePaths2.findUserModulePaths)({
    rootDir: rootDir,
    fixturesDir: fixturesDir,
    fixtureFileSuffix: fixtureFileSuffix
  }),
      fixturePaths = _findUserModulePaths.fixturePaths,
      decoratorPaths = _findUserModulePaths.decoratorPaths;

  return getCompiledTemplate({
    globalImports: genGlobalRequires(globalImports),
    rendererConfig: stringifyRendererConfig(rendererConfig),
    fixtures: genRequireMap(fixturePaths, rootDir),
    decorators: genRequireMap(decoratorPaths, rootDir)
  });
}

function genGlobalRequires(paths) {
  if (paths.length === 0) {
    return '';
  } // Forward slashes are necessary via slash() to avoid double-escaping
  // backslashes on Windows


  return ['', '// Keeping global imports here is superior to making them bundle entry points', '// because this way they become hot-reloadable'].concat(_toConsumableArray(paths.map(function (importPath) {
    return "require('".concat((0, _slash.default)(importPath), "');");
  })), ['']).join("\n");
}

function genRequireMap(paths, rootDir) {
  if (paths.length === 0) {
    return '{}';
  }

  var requireRows = paths.map(function (p) {
    var relPath = (0, _slash.default)(_path.default.relative(rootDir, p));
    return "\n  '".concat(relPath, "': require('").concat(p, "').default");
  });
  return "{".concat(requireRows.join(', '), "\n}");
}

function stringifyRendererConfig(rendererConfig) {
  return JSON.stringify(rendererConfig, null, 2);
}

function getCompiledTemplate(_ref) {
  var globalImports = _ref.globalImports,
      rendererConfig = _ref.rendererConfig,
      fixtures = _ref.fixtures,
      decorators = _ref.decorators;
  return "// This file is automatically generated by Cosmos\n".concat(globalImports, "\nexport const rendererConfig = ").concat(rendererConfig, ";\nexport const fixtures = ").concat(fixtures, ";\nexport const decorators = ").concat(decorators, ";\n");
}